\chapter{√âtat de l'art}\label{state_art_chap}

Tous les langages de programmation modernes d√©finissent au moins une
repr√©sentation standard des cha√Ænes de caract√®res, que ce soit
sous forme de tableau, de liste cha√Æn√©e ou de corde.

Parmi les impl√©mentations existantes, une majorit√© repr√©sente leurs cha√Ænes
de caract√®res sous forme de tableau de caract√®res.
Malgr√© cette ressemblance, des diff√©rences de conception,
de codage et d'impl√©mentation viennent changer la fa√ßon
d'interagir avec les cha√Ænes de caract√®res d'un langage √†
l'autre.
Ce chapitre a pour but de les introduire, et d'expliquer quels
sont les avantages et inconv√©nients de chaque impl√©mentation.

Nous pr√©sentons d'abord les mod√®les de cha√Ænes mutables et immutables,
puis nous comparons les avantages et inconv√©nients que chaque approche
offre.
Nous poursuivons sur une pr√©sentation des diff√©rentes structures de
donn√©es existantes √† la r√©daction de ce document: tableaux de caract√®res,
listes cha√Æn√©es et cordes.
Nous terminons ce chapitre par les probl√©matiques de codage, et plus
particuli√®rement d'Unicode.

\section{Mutable vs. Immutable}

Ind√©pendamment de la structure, une cha√Æne de caract√®res peut √™tre soit mutable,
soit immutable.
Une cha√Æne immutable est d√©finie comme une cha√Æne dont le contenu ne peut pas
√™tre modifi√© via des fonctions de manipulation.
Il est √† noter cependant que la structure m√™me des cha√Ænes immutables peut √™tre
mutable, par exemple pour des m√©canismes d'am√©lioration de la performance comme
des syst√®mes de cache.

Parmi les langages de haut niveau populaires lors de la r√©daction de ce document,
beaucoup pr√©f√®rent les cha√Ænes de caract√®res immutables.
C'est le cas de Java \cite{java_spec}\footnote{Voir documentation √†
\url{http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/b95e325137b4/src/share/classes/java/lang/String.java},
\texttt{Strings are constant}.}, C\# \cite{csharp_spec}, Python \cite{pythonref}\footnote{Impl√©mentation
disponible √† \url{https://github.com/python/cpython/tree/c797daf69edc52385ba78447441e1a65c7cf5730/Objects/stringlib}.},
Scala \cite{scalaspec}, JavaScript \cite{ecmascript_spec}, etc.

√Ä premi√®re vue, cette d√©cision peut para√Ætre limitante du fait qu'elle
emp√™che certaines op√©rations de fa√ßon efficace (concat√©nation,
modification, etc.). Cependant, elle assure la stabilit√© de la cha√Æne
de caract√®res tout au long de l'ex√©cution du programme, et ce, peu importe le
nombre de modifications qu'elle subira, chaque modification entra√Ænant une copie.
Cette propri√©t√© garantit un comportement s√ªr en programmation parall√®le et concurrente.
En programmation s√©quentielle aussi, les structures immutables sont
g√©n√©ralement plus simples √† manipuler du fait de l'absence d'effets de
bord √† la modification.
Ces avantages induisent une meilleure stabilit√© et une probabilit√© de
comportement bogu√© plus faible.

L'immutabilit√© des cha√Ænes de caract√®res permet √©galement d'√©viter
certaines op√©rations de copie en partageant des sous-parties de la
cha√Æne initiale.
Cela permet le support de certaines op√©rations
en temps constant au lieu de lin√©aire (substring, trim, etc.).

Les probl√®mes de concat√©nation et modification inefficaces ont √©t√© adress√©s
dans la plupart de langages ayant fait ce choix par l'introduction d'une
repr√©sentation mutable des cha√Ænes de caract√®res: le \texttt{buffer}.

Cette structure permet d'effectuer des modifications
de la cha√Æne sans n√©cessiter de r√©-allocation.
Cela a pour effet de combler les limites
apport√©es par l'immutabilit√© en permettant de modifier le contenu d'une
cha√Æne de fa√ßon efficace en g√©n√©ral.
Des diff√©rences d'impl√©mentation sont √† noter en ce qui concerne les \texttt{buffers} en revanche.

Les langages utilisant des cha√Ænes de caract√®res mutables ne subissent pas ces
d√©savan-tages et s'affranchissent du \texttt{buffer}.
C \cite{cspec}, C++ \cite{cppspec}, Fortran \cite{fortranspec} et d'autres langages
de bas-niveau en font partie.
Leur choix peut s'expliquer du fait de l'orientation performance et bas-niveau
de cette famille de langages.
Il est √† noter cependant que le manque de m√©tadonn√©es pour la longueur
de la cha√Æne dans certains de ces langages (voir~\ref{state_structs}) force les d√©veloppeurs
√† √©crire leurs propres versions de cha√Ænes mutables pour acc√©l√©rer l'op√©ration
de concat√©nation.

En plus de ces langages orient√©s performance, certains langages de plus haut-niveau utilisent
des cha√Ænes mutables.
Ruby \cite{rubyref}\footnote{Impl√©mentation disponible √†
\url{https://github.com/ruby/ruby/blob/trunk/string.c}.} en est un exemple.
Une fonction d√©finie sur les objets, \texttt{freeze}, permet de garantir la non-mutabilit√©
du receveur en provoquant une exception en cas de mutation.
Ruby utilise aussi des conventions de nommage pour discriminer les op√©rations alt√©rantes
des op√©rations de copie: si le nom du service est suffix√© par '!', il s'agit d'un service
mutatif, sinon, il produira une copie.

Le tableau~\ref{mutable_langs} r√©capitule les diff√©rents langages et leurs politiques vis-√†-vis de
la mutabilit√© de leurs structures.

\begin{table}
	\caption{\label{mutable_langs}Langages et structures}
	\centering
	\begin{tabular}{lll}
		\hline
		Langage & Immutable & Mutable \\
		\hline
		Java & String & StringBuffer ou StringBuilder \\
		C\# & String & StringBuilder¬†\\
		C & char* (lorsque cha√Ænes lit√©rales) & char* \\
		Ruby & frozen String & String \\
		Python & str & / \\
		Perl & Str & Buf \\
		Nit & String & Buffer\\
		Swift & string & / \\
		Go & string & / \\
		C++ & char* (lorsque cha√Ænes lit√©rales) & std::string \\
		\hline
	\end{tabular}
\end{table}

\section{Structures de donn√©es}\label{state_structs}

Il existe plusieurs structures pour repr√©senter les cha√Ænes de caract√®res dans les langages
de programmation.
Nous nous int√©ressons seulement ici aux structures destin√©es au stockage des cha√Ænes
de caract√®res pour une utilisation g√©n√©rique.
La litt√©rature existante dans ce domaine est tr√®s faible dans la mesure o√π les
programmeurs et impl√©menteurs de langages se contentent g√©n√©ralement de cha√Ænes plates.
Des structures sp√©cialis√©es et les algorithmes li√©s √† ces structures sont, ou ont √©t√©
un sujet de recherche actif: tri \cite{bentley1997, hat_trie},
hachage \cite{pearson1990fast, mckenzie1990selecting},
recherche \cite{suffix_arrays, boyer1977fast}, etc.

Cette section les d√©taillera et exposera leurs avantages et inconv√©nients.
Nous commen√ßons par le tableau de caract√®res d√ª √† sa simplicit√© et sa popularit√©.
Nous pr√©sentons par la suite la liste cha√Æn√©e, repr√©sentation favorite des langages
fonctionnels.
Puis nous terminons cette section par une structure souvent oubli√©e: la \texttt{corde}.

\subsection{Tableau de caract√®res}\label{state_flatstr_prez}

Nous commen√ßons par la structure la plus ancienne et la plus populaire pour la
repr√©-sentation du texte: le tableau de caract√®res, tel qu'illustr√© dans la figure~\ref{flatexample}.
Du fait de la lin√©arit√© de la structure, nous allons r√©-utiliser les termes de
Boehm \cite{Boehm95}, et qualifier cette repr√©sentation de ¬´cha√Æne plate¬ª dans le reste
de ce document.

Il existe deux repr√©sentations de cette structure:
\begin{enumerate}
	\item Les cha√Ænes C, termin√©es par un caract√®re nul (illust√© par \texttt{\textbackslash0} dans notre exemple).
	\item Les cha√Ænes Pascal, repr√©sent√©es comme des structures contenant un premier champ de longueur, suivi du contenu de la cha√Æne.
\end{enumerate}

Du fait que dans les langages comme C, la cha√Æne ne poss√®de pas d'information de longueur dans sa
structure, il a √©t√© d√©cid√© de terminer les cha√Ænes de caract√®res par l'octet 0x00 et les fonctions
C travaillant sur des cha√Ænes se servent de cette s√©mantique pour d√©terminer
la fin du traitement.
Cette s√©mantique est √† l'origine de nombreuses failles de s√©curit√© comme des d√©passements
de tampon et leur pr√©vention est laiss√©e au programmeur, complexifiant le code.
Les cha√Ænes Pascal √©vitent ce probl√®me en incluant la longueur directement dans les donn√©es de la structure.
Cependant, ces derni√®res forcent la cha√Æne √† se limiter √† la taille de la donn√©e contenant
l'information de longueur et d√©pend donc de l'architecture cible pour le programme.

\begin{figure}
	\caption{Cha√Æne de caract√®res plate}
	\label{flatexample}
	\centering
	\includegraphics{figures/flat.pdf}
\end{figure}

Ind√©pendamment de l'impl√©mentation, qu'elle soit similaire √† C, ou √† Pascal, la structure poss√®de
ses avantages et inconv√©nients.

Avantages:
\begin{enumerate}
	\item acc√®s index√© constant √† un codet;
	\item bonne performance en cache.
\end{enumerate}

Inconv√©nient:
\begin{enumerate}
	\item besoin d'espace contigu.
\end{enumerate}

Du fait de cet inconv√©nient, cette repr√©sentation des cha√Ænes de caract√®res peut
d√©g√©n√©rer assez rapidement en terme d'espace et de co√ªt.
En effet, lorsqu'une cha√Æne de caract√®res mutable est pleine, il faut r√©allouer
un espace plus grand et copier les anciennes donn√©es vers le nouvel espace.
Cette op√©ration est peu co√ªteuse sur les cha√Ænes de caract√®res de petite taille, les
co√ªts d'allocation et de copie √©tant n√©gligeables dans ce cas.
En revanche cela peut d√©g√©n√©rer sur de grandes cha√Ænes de caract√®res.

Ce probl√®me des cha√Ænes plates est encore aggrav√© avec l'immutabilit√©,
dans la mesure o√π la moindre op√©ration de mutation entra√Æne une
r√©allocation compl√®te de la cha√Æne.
L'impact de cette r√©-allocation est g√©n√©ralement r√©duit dans les impl√©mentations
de \texttt{buffer} par le biais de sur-allocations.
L'approche ici est de pr√©-allouer une quantit√© de m√©moire sup√©rieure √† ce qui est
demand√© pour amortir les co√ªts de l'allocation et de la copie sur un nombre suffisant de
concat√©nations.
La performance expos√©e ici est dans le cas g√©n√©ral, suffisante pour les op√©rations
de concat√©nation multiples, les cas d√©g√©n√©ratifs (insertion non-terminale d'une
cha√Æne) expos√©s par cette solutions √©tant rares, il est par cons√©quent peu fr√©quent
que les biblioth√®ques proposent une solution efficace et standard √† ces probl√®mes.

\subsection{Liste cha√Æn√©e}

Dans le monde fonctionnel, la repr√©sentation en tableau est bien souvent √©clips√©e
par la liste cha√Æn√©e, repr√©sent√©e dans la figure~\ref{llistexample}.
Les langages h√©rit√©s de Lisp utilisent cette structure.
C'est √©galement le cas d'Haskell.

\begin{figure}
	\caption{Exemple de liste cha√Æn√©e}
	\label{llistexample}
	\centering
	\includegraphics{figures/linked_list.pdf}
\end{figure}

Elle poss√®de certains avantages par rapport √† un tableau, notamment la capacit√© d'extension
en temps constant\footnote{Lorsque la mutabilit√© des structures est support√©e, sinon l'op√©ration
effectu√©e en temps lin√©aire.}.
Notons que si l'op√©ration d'insertion s'effectue en temps constant, l'op√©ration de
recherche du point d'acc√®s se fait n√©anmoins en temps lin√©aire, √† l'exception √©ventuellement
des extr√™mit√©s.
Il est √©galement possible d'amortir l'op√©ration en temps constant par le
biais d'un syst√®me de cache.

La repr√©sentation est n√©anmoins peu populaire dans les langages proc√©duraux et √† objets, le
d√©savantage majeur de la solution est sa faible performance dans le cas de sous-cha√Ænage,
ce dernier n√©cessitant la r√©allocation de chaque caract√®re afin de produire une nouvelle
cha√Æne.
L'it√©ration, bien que th√©oriquement aussi performante qu'une approche par tableau, est mise √†
mal par les caract√©ristiques des processeurs modernes de par son impossibilit√© √† √™tre
mise en cache efficacement.
La probl√©matique de l'utilisation m√©moire est aussi √† prendre en compte.
En effet, chaque caract√®re est stock√© dans un maillon; sa taille est donc la somme de
la taille du caract√®re et d'un un pointeur, au minimum.

\subsection{Corde}

Une autre alternative existe: la \texttt{corde} \cite{Boehm95}, illustr√©e dans la figure~\ref{ropeexample}.

\begin{figure}
	\caption{Exemple de corde}
	\label{ropeexample}
	\centering
	\includegraphics{figures/rope.pdf}
\end{figure}

Une corde est un arbre binaire accessible par index.
Chaque noeud de l'arbre est un noeud repr√©sentant une concat√©nation.
Les \texttt{feuilles} quant √† elles sont des cha√Ænes de caract√®res plates.

La structure propose de r√©duire la complexit√© d'op√©rations comme la concat√©nation √† un
temps constant en remplacant l'allocation et la copie du contenu des cha√Ænes par
la cr√©ation d'un noeud de concat√©nation.
Cet avantage est n√©anmoins √† nuancer du fait de la n√©cessit√© de r√©-√©quilibrer la corde
p√©riodiquement pour assurer les bonnes performances de la structure.
Elle permet √©galement de r√©duire la complexit√© temporelle des op√©rations comme
l'insertion dans une cha√Æne √† O(log(n)).
Cette op√©ration s'effectue en trois √©tapes:

\begin{enumerate}
	\item le parcours jusqu'a la feuille √† s√©parer (O(log(n)) si la corde est √©quilibr√©e);
	\item la s√©paration en deux parties √† l'index d'insertion (complexit√© √©quivalente √† deux substring + deux allocations de noeud de concat√©nation);
	\item la r√©-√©criture du parcours jusqu'a la racine (O(log(n))).
\end{enumerate}

Avantages:
\begin{enumerate}
	\item concat√©nation efficace en temps et en espace;
	\item potentiel de partage des feuilles (moins d'allocations).
\end{enumerate}

Inconv√©nients:
\begin{enumerate}
	\item acc√®s en O(log(n)) aux feuilles de la cha√Æne;
	\item besoin de garder la structure √©quilibr√©e pour maintenir la complexit√© en O(log(n)).
\end{enumerate}

Malgr√© son introduction il y'a pr√®s de 20 ans, cette structure n'est
jamais devenue populaire, et a fini par tomber dans les limbes.
Cependant, il y'a eu des cas de re-d√©couverte dans lesquels les cordes
√©taient plus pertinentes √† utiliser que des cha√Ænes plates comme les √©diteurs de
texte \cite{inria_rope}.

\subsection{Conclusion}

Parmi les langages modernes, peu proposent une alternative √† la cha√Æne plate comme structure de
donn√©es pour les cha√Ænes de caract√®res.
En dehors des langages √† objets ou proc√©duraux, la liste cha√Æn√©e est privil√©gi√©e dans les
langages fonctionnels, qui eux aussi √©vitent la corde.
Nit est donc un des rares langages √† int√©grer les cordes dans leur biblioth√®que standard.
Julia~\cite{bezanson2012julia} propose √©galement les cordes, cependant elle est d√©pr√©ci√©e\footnote{
\url{https://github.com/JuliaLang/julia/blob/86cd5ea3c61426ebddd1d3809ffa869d6726fb30/base/deprecated.jl}}
pour des raisons de peformance, ceux-ci ne proposant pas de syst√®me de conversion, elle doit √™tre
explicitement instanci√©e par les utilisateurs.
Ces derniers en abusant, les performances diminuaient, ce qui a men√© √† sa d√©pr√©ciation.

\section{Codage}

Les cha√Ænes de caract√®res en tant que telles sont des s√©quences de caract√®res.
Selon le codage utilis√©, la d√©finition de caract√®re peut varier.

√Ä l'origine, il n'existait pas de standard pour la repr√©sentation des caract√®res.
Chaque syst√®me poss√©dait sa variation d'une correspondance entre donn√©es binaires
et caract√®res.
√Ä l'apparition des cartes perfor√©es, les codages des caract√®res √©taient propri√©taires.
Chaque producteur de cartes poss√©dait son propre codage, ce qui emp√™chait
l'interop√©rabilit√© entre diff√©rents fabricants.

Simultan√©ment, en 1963, deux codages sont apparus et seront la base des deux grandes
familles de codages ayant fa√ßonn√© l'histoire de l'informatique: \textit{American Standard
Code for Information Interchange} (ASCII) \cite{ASA63} et \textit{Extended Binary Coded Decimal
Interchange Code} (EBCDIC) \cite{amdahl1964architecture}.
Le premier √©tant un effort de l'\textit{American Standards Association} (ASA), anc√™tre de 
l'\textit{American National Standards Institute} (ANSI) et devenant un standard de facto au
d√©part, avant sa normalisation par ISO/IEC via l'ISO/IEC-646 \cite{ISO72}.
L'autre √©tant une extension du codage propri√©taire d'IBM, \textit{Binary Coded Decimal},
d√©j√† utilis√© sur les cartes perfor√©es du fabricant.

ISO/IEC-646 marque le d√©but de la standardisation des codages de caract√®res en informatique.
Il d√©finit une multitude de codages sur 7 bits pour les caract√®res de l'alphabet latin.
Il est suivi, dans les ann√©es 1980 des variantes de l'ISO/IEC-8859 ou ECMA-94 \cite{ECMA94} du c√¥t√© europ√©en.

Les limites de l'ASCII ou de l'ISO-8859 se sont vite fait ressentir dans les pays √©trangers, si bien
qu'une multitude de codages ont commenc√© √† appra√Ætre dans le monde entier; JIS X 208 \cite{JISX208}
pour le Japon, GOST 10859 \cite{GOST64} pour l'URSS, remplac√© plus tard par KOI-8 \cite{KOI8} et ses
d√©riv√©es, GB2312 \cite{GB2312} pour la Chine, les variantes de Big5 \cite{big5cite} pour Taiwan,
Hong-Kong et Macau, etc.

La multitude de codages rendait l'√©change d'information entre les pays difficile, voire dans certains cas
√† l'int√©rieur d'un m√™me pays, ce qui motiva la cr√©ation d'Unicode \cite{Unicode91}.
En conjonction avec l'ISO/IEC, le consortium Unicode et IEEE partici-p√®rent √† l'√©laboration
d'\textit{Universal Character Set} (UCS) \cite{UCS1993}.

\subsection{UCS-2}

Quand les travaux sur Unicode ont commenc√©, en 1988, le standard √† venir ne concernait
qu'un codage et une table de caract√®res; les deux √©taient confondus \cite{Unicode88}.
L'espace pr√©vu par Unicode pour d√©crire les caract√®res support√©s √©tait de 16 bits (65536 valeurs).
Chaque valeur d√©finie dans le standard est appel√©e selon Unicode un \texttt{point de code}.
Pour coder cette information, UCS-2 (alors appel√© Unicode) est d√©crit dans la premi√®re version du
standard \cite{Unicode91}.

Il s'agit d'un codage √† longueur fixe, √† l'instar de ISO-646 ou ISO-8859, chaque valeur poss√®de
un caract√®re associ√©.
Du fait de ses codets de 16 bits, UCS-2 est vuln√©rable aux probl√®mes de boutisme, contrairement
aux codages utilisant l'octet comme codet.
Pour palier ce probl√®me dans les fichiers, Unicode pr√©conise l'utilisation d'un
BOM\footnote{Byte Order Mark, point de code 0xFEFF d√©terminant le boutisme d'un bloc de texte Unicode.}
dans les fichiers Unicode.
Si le fichier est cod√© en UTF-16, les deux premiers octets seront soit \texttt{0xFFFE} dans le cas de
petit-boutisme ou \texttt{0xFEFF} dans le cas de gros-boutisme.
√Ä la publication d'ISO-10646 dans sa premi√®re version \cite{UCS1993}, il est l'un des deux codages couverts
par la norme, l'autre √©tant UCS-4.

\subsection{UCS-4}

UCS-4 est similaire √† UCS-2 dans le sens o√π il propose un codage de longueur fixe.
La diff√©rence est que UCS-4 propose des codets de 32 bits au lieu de 16 bits.
La raison √† cela est un conflit d'opinion entre le consortium Unicode et
le sous-groupe d'ISO/IEC responsable de la normalisation d'UCS.
Le Consortium Unicode √©tait convaincu que 16 bits suffiraient pour coder l'int√©gralit√©
des caract√®res du monde entier, l√† o√π ISO/IEC proposait de normaliser un espace de
donn√©es de 32 bits coup√© en plans de 65536 valeurs.
Pour les m√™mes raisons qu'UCS-2, cette repr√©sentation est vuln√©rable aux probl√®mes de
boutisme.

Lors de la fusion des deux normes, les deux codages ont √©t√© ajout√©s aux documents.
Unicode ne sp√©cifiait que les 65536 premi√®res valeurs et ISO/IEC supportait l'ajout
ult√©rieur de nouvelles valeurs dans l'espace disponible.

\subsection{UTF-8}

UTF-8 est un des codages d√©finis par Unicode et ISO/IEC-10646.
La premi√®re version a √©t√© produite par Rob Pike et Ken Thompson d√®s
1992 et impl√©ment√©e dans le syst√®me d'exploitation de recherche Plan9 \cite{Plan9}.

UTF-8 a √©t√© cr√©√© pour deux raisons principales; la premi√®re √©tant la r√©tro-compatibilit√© avec
ASCII et les cha√Ænes de caract√®res C, termin√©es par un octet nul (0x00).
La deuxi√®me raison est que les concepteurs d'UTF-8, conscients du diff√©rend de point
de vue entre Unicode et ISO/IEC, ne voulaient pas se borner aux 16 bits d√©finis par
Unicode et √©taient m√©contents d'UCS-4 √† cause de la perte d'espace occasionn√©e par les codets de 32 bits.
UTF-8 est donc un codage √† longueur variable ayant pour codet l'octet.
Il est capable de coder l'int√©gralit√© des points de code support√©s par ISO/IEC 10646.

Chaque point de code est cod√© sur une s√©quence de 1 √† 6 octets.
Le premier octet de la s√©quence d√©termine la longueur de la s√©quence, par la suite,
chaque octet de la s√©quence doit respecter le motif '10'.
Le tableau~\ref{utf8_sequences} montre l'organisation des s√©quences UTF-8.

\begin{table}
	\caption{\label{utf8_sequences}Organisation des s√©quences UTF-8}
	\centering
	\begin{tabular}{llllll}
		\hline
		Point de code & Glyphe & Octet 1 & Octet 2 & Octet 3 & Octet 4\\
		\hline
		0x41 & A & 0x41 & & & \\
		0xC9 & √â & 0xC3 & 0x89 & & \\
		0x3042 & {\fontspec{WenQuanYi Micro Hei}„ÅÇ} & 0xE3 & 0x81 & 0x82 & \\
		0x1F60A & {\fontspec{DejaVu Sans}üòä} & 0xF0 & 0x9F & 0x98 & 0x8A \\
		\hline
	\end{tabular}
\end{table}

\subsection{UTF-16}

√Ä la version 2.0 d'Unicode, le nombre total de caract√®res d√©finis a d√©pass√© les 65536 pr√©vus
√† la base par Unicode.
Pour palier ce probl√®me, le consortium Unicode a fait √©voluer UCS-2 en UTF-16.

Le codage fonctionne par un syst√®mes de paires compl√©mentaires et est capable de coder un total
de 1 114 111 caract√®res.
√Ä la date de r√©daction de ce m√©moire, 120 737 points de code sont assign√©s \cite{Unicode8}.
De ce fait, le standard est limit√© depuis √† ce nombre de points de code.
UTF-8 n'ayant plus besoin de supporter 2 milliards de points de code, sa sp√©cification est simplifi√©e
et le nombre maximal de codets est limit√© √† 4.
Des points de codes compris entre 0xD800 et 0xDFFF sont r√©serv√©s pour coder les paires compl√©mentaires
et ne sont valides qu'en UTF-16.

Le tableau~\ref{unicode_sequences} montre les diff√©rentes repr√©sentations possibles du caract√®re {\fontspec{DejaVu Sans}üòä} 
en fonction des diff√©rents codages Unicode.

\begin{table}
	\caption{\label{unicode_sequences}Repr√©sentation du caract√®re {\fontspec{DejaVu Sans}üòä} dans les codages Unicode}
	\centering
	\begin{tabular}{lllll}
		\hline
		Codage & Octet 1 & Octet 2 & Octet 3 & Octet 4\\
		\hline
		UTF-8 & 0xF0 & 0x9F & 0x98 & 0x8A \\
		UTF-16 BE & 0xD8 & 0x3D & 0xDE & 0x0A \\
		UTF-16 LE & 0x3D & 0xDE & 0x0A & 0xDE \\
		UTF-32 BE & 0x00 & 0x01 & 0xF6 & 0x0A \\
		UTF-32 LE & 0x0A & 0xF6 & 0x01 & 0x00 \\
		\hline
	\end{tabular}
\end{table}

\subsection{Support d'Unicode dans les langages de programmation}

Parmi les langages modernes, presque tous poss√©dant des s√©mantiques li√©es √† Unicode dans leur
gestion des cha√Ænes de caract√®res.

Le niveau de support d'Unicode varie selon les langages, certains supportent les
op√©ra-tions de base de fa√ßon correcte vis-√†-vis du standard.
D'autres supportent les extensions li√©es aux locales (ce qui est n√©cessaire pour
le tri par exemple).

Au niveau des codages par exemple, Java et C\# utilisent UTF-16 en interne,
les op√©rations de modification sont fonctionnelles avec des s√©mantiques
d'Unicode et offrent √©galement des extensions de locales.

Python, avant sa version 3, offrait deux types de cha√Ænes de caract√®res.
\texttt{str}, qui est compos√© de octets arbitraires, et \texttt{unicode}, compos√©
de codets UTF-16 \cite{PEP100}, ou de codets UTF-32 si l'interpr√©teur est compil√©
pour les utiliser en interne.
Plus tard, une extension des caract√®res pousse le codage
des cha√Ænes de caract√®res en UTF-32, si le programmeur le demande
explicitement.
En Python 3, le PEP 393 \cite{PEP393} change l'impl√©mentation interne en codets ISO8859-1,
UTF-16 ou UTF-32 d√©pendamment du plus grand point de code de la cha√Æne.

Ruby ne d√©finit pas de codage par d√©faut pour ses cha√Ænes de caract√®res,
chacune d'elles poss√®de son propre codage et les op√©rations qui les
manipulent sont diff√©rentes en fonction du codage de la cha√Æne.
Les deux raisons principales de cette approche sont:
\begin{enumerate}
	\item la r√©duction du nombre d'op√©rations de codage/d√©codage √† la lecture ou l'√©criture vers un m√©dia;
	\item une protection contre les probl√®mes √† long-terme du choix d'un codage unique (d√©pr√©ciation, √©volution
de la norme, etc.).
\end{enumerate}

\subsection{√âvolution des op√©rations avec Unicode}\label{unicode_troubles}

Avant l'arriv√©e d'Unicode, les op√©rations sur des cha√Ænes de caract√®res √©taient efficaces du fait
de la simplicit√© des normes et du codage sous-jacent.
Les comparaisons se basaient sur la valeur du codet, les manipulations pour changer la casse
des caract√®res se r√©sumaient √† des op√©rations arithm√©tiques ou des acc√®s √† une table.
Unicode vient bouleverser cette s√©mantique et complexifier l'ensemble des manipulations.

Prenons l'exemple de l'√©quivalence de cha√Ænes de caract√®res; l'apparition de caract√®res combinants
vient complexifier l'op√©ration dans la mesure o√π les combinaisons de points de code doivent
√™tre r√©solues avant d'effectuer une comparaison entre deux cha√Ænes (voir tableau~\ref{combining_example}).
Il existe √©galement le probl√®me de caract√®res isomorphes; des
glyphes\footnote{Repr√©sentation graphique d'un signe typographique.} repr√©sentant des caract√®res diff√©rents
sont √©quivalents ou tout du moins tr√®s similaires (exemple: le signe d'Angstr√∂m √Ö et le A-Ring utilis√©
dans les alphabets nordiques √Ö).
L'ensemble de ces cas doivent √™tre pris en compte pour assurer une comparaison respectant le standard
Unicode.

\begin{table}
	\caption{\label{combining_example}Exemple de caract√®res combinants √† glyphe √©quivalent}
	\centering
	\begin{tabular}{lll}
		\hline
		Glyphe & Point de code & Code Combinant \\
		\hline
		√Ö & U+00C5 &   \\
		√Ö & U+0041 & U+030A¬†\\
		√Ö & U+212B &  \\
		\hline
	\end{tabular}
\end{table}

Il existe √©galement une deuxi√®me fa√ßon sp√©cifi√©e de comparer deux cha√Ænes: la compa-tibilit√©.
Il s'agit de permettre la prise en compte de versions s√©mantiquement √©gales mais graphi-quement diff√©rentes
d'un m√™me caract√®re.
Sous cette forme de comparaison, les cha√Ænes \og H2O \fg{} et \og H$_{2}$O \fg{} doivent √™tre consid√©r√©es
comme √©gales.

Si l'√©galit√© canonique est pr√©visible et fiable, l'ordonnancement de caract√®res est autre-ment plus complexe
car d√©pendant de la locale, les lettres doivent √™tre ordonn√©es diff√©remment dans certains contextes.
Par exemple: \og ll \fg{} va √™tre consid√©r√© comme deux lettres dans les pays d'europe, sauf en espagne o√π
\og ll \fg{} est
une ligature\footnote{Fusion de deux graph√®mes d‚Äôune √©criture pour n‚Äôen former qu‚Äôun seul nouveau.} consid√©r√©e
comme une lettre ind√©pendante, qui poss√®de sa rubrique dans un dictionnaire ou un bottin t√©l√©phonique,
situ√©e entre le \og l \fg{} et \og m \fg{}.
Il existe √©galement des cultures o√π il n'existe pas d'ordre officiel de comparaision (ex: Japon) et d'autres
o√π plusieurs ordres sont disponibles (ex: Allemagne).

Ces probl√®mes de s√©mantique am√®nent des probl√®mes de recherche de motifs: veut-on se baser sur
l'√©quivalence canonique ou sur de la compatibilit√© lors de la recherche? √Ä quel point veut-on sacrifier de
la performance pour de la simplicit√© d'utilisation?

Des modifications comme \texttt{trim}\footnote{Suppression des caract√®res d'espacement au d√©but et √† la fin d'une chaine de caract√®res.}
deviennent √©galement complexes dans la mesure o√π les espaces ne sont
plus confin√©s √† un espace restreint comme ASCII ou ISO-8859 l'avaient d√©fini, mais √† toute la table
Unicode.
De plus, certains caract√®res sont reconnus comme des caract√®res d'espacement, mais n'en ont pas
n√©c√©ssairement l'air: U+1680 par exemple, est un caract√®re d'espacement en alphabet Ogham, un alphabet runique
irlandais, dont le glyphe ressemble √† un \texttt{-}.

Les op√©rations de modifications de caract√®res sont elles-aussi d√©pendantes de la locale.
Par exemple le caract√®re \og i \fg{} va se transformer en \og I \fg{} pour la majorit√© des utilisateurs,
sauf en locale Turque, ou il sera repr√©sent√© par le caract√®re \og ƒ∞ \fg{}.
Par ailleurs, les op√©rations de modification de casse sont non sym√©triques.
En allemand, le caract√®re \og √ü \fg{} se transforme en \og SS \fg{} une fois en majuscule, qui eux, se transforment
en \og ss \fg{} une fois en minuscule.
Cette s√©mantique pose √©galement un probl√®me pour les API retournant un caract√®re lors de
l'op√©ration dans la mesure ou un caract√®re unique peut se transformer en une cha√Æne de
caract√®res.

\subsection{D√©finition: caract√®re}

Dans la mesure o√π une cha√Æne de caract√®res est une suite de caract√®res,
un point sur lequel tous les langages pourraient √† priori sembler
d'accord est la notion m√™me de caract√®re.

En r√©alit√©, il n'existe pas de consensus concernant le caract√®re.
Il peut √™tre une entit√© compl√®tement diff√©rente d'un langage
√† l'autre.
Parfois pour des raisons historiques (Java et ses codets UTF-16), parfois
de vision (Go avec UTF-8 ou Swift avec ses Extended Grapheme Clusters), voire dans
certains cas la notion est inexistante (Ruby, Python, etc.).

C et C++ consid√®rent des cha√Ænes de caract√®res comme des
tableaux d'octets termin√©s par un octet 0x00.
Avec l'arriv√©e d'Unicode, un type \texttt{wchar\char`_t} a √©t√© ajout√© au standard
pour supporter les codages comme UTF-16 ou UTF-32.
Cet ajout n'est cependant pas exempt de d√©faut et certains projets comme
GNU libunistring\footnote{The \texttt{wchar\char`_t} mess - \url{https://www.gnu.org/software/libunistring/manual/html_node/The-wchar_005ft-mess.html}.}
critiquent avec v√©h√©mence le type de donn√©es du fait de son manque de standardisation,
de sa faible utilit√© dans les impl√©mentations limitant sa taille √† 16 bits, ainsi que
de la fragilit√© des API associ√©es.

Des langages plus haut-niveau comme Java \cite{java_spec} d√©finissent leurs caract√®res comme
des codets UTF-16.
Ils ont une taille fixe de 16 bits et la gestion des paires d'extension est laiss√©e
au programmeur.
C\# \cite{csharp_spec} et Javascript \cite{ecmascript_spec} le d√©finissent de fa√ßon similaire.

Go \cite{goref} d√©finit un concept analogue √† un point de code nomm√©
Rune, √† l'instar des Runes d√©fninies par Plan9 \cite{Plan9}.
Leurs cha√Ænes de caract√®res sont en fait des tableaux d'octets et ils
poss√®dent des op√©rations pour les traiter comme de l'UTF-8, 16 ou 32, le codage des cha√Ænes
√©tant UTF-8 par d√©faut.

Swift \cite{swiftref} est un des rares langages statiquement typ√©s et compil√©s √† d√©finir un
caract√®re comme une structure non primitive.
En Swift, un caract√®re est d√©fini comme un ensemble √©tendu de graph√®mes \cite{Unicode8}.
Il s'agit d'une s√©quence d'un ou plusieurs points de code, qui
combin√©s, produisent un caract√®re lisible par un √™tre humain.

D'autres langages comme Ruby ou Python sont compl√®tement d√©pourvus de la notion de
caract√®re, et un acc√®s √† une cha√Æne de caract√®res renvoie syst√©matiquement
une sous-cha√Æne.
Perl, dans sa version 6, d√©finit plusieurs niveaux d'acc√®s aux √©l√©ments d'une cha√Æne:
octets, points de code, graph√®mes.

\subsection{Conclusion}

La notion de codage est variable selon les langages (voir tableau~\ref{coding_recap}).
Certains d√©finissent un codage par d√©faut, d'autres en supportent explicitement
plusieurs, voire certains ne font pas de distinction entre objet binaire et cha√Æne
de caract√®res.
De cette notion d√©coule directement la notion de caract√®re, elle aussi ambig√ºe.

\begin{table}
	\caption{\label{coding_recap}Codage, selon les langages}
	\centering
	\begin{tabular}{llllll}
		\hline
		& Aucun & Variable & UTF-8 & UTF-16 & UTF-32 \\
		\hline
		Java & Non & Non & Non & Oui & Non \\
		C\# & Non & Non & Non & Oui & Non \\
		C & Oui & Non & Non & Non & Non \\
		Ruby & Non & Oui & Oui (d√©faut) & Oui & Oui \\
		Python & Non & Oui & Non & Oui (UCS-2) & Oui \\
		Perl & Non & Oui & Oui (d√©faut) & Oui & Oui \\
		Nit & Non & Non & Oui & Non & Non \\
		Swift & Non & Non & Non & Oui & Non \\
		Go & Non & Oui & Oui (d√©faut) & Oui & Oui \\
		\hline
	\end{tabular}
\end{table}

\section{Op√©rations primitives}

Nous identifions trois op√©rations primitives des cha√Ænes de caract√®res dans cette √©tude.
Ces trois op√©rations serviront √† impl√©menter l'ensemble des op√©rations sur des cha√Ænes
de caract√®res et d√©termineront la complexit√© globale sur ces derni√®res.

\subsection{Concat√©nation}

Le processus de concat√©nation est la cr√©ation d'une nouvelle cha√Æne de caract√®res √† partir
de deux morceaux, eux-m√™mes des cha√Ænes de caract√®res ind√©pendantes.
L'op√©ration est effectu√©e de plusieurs fa√ßons dans les langages actuels.

Java et C\# par exemple travaillent avec des cha√Ænes de caract√®res plates, l'utilisation de
l'op√©rateur de concat√©nation provoque l'allocation d'un nouvel espace pour le
contenu des deux cha√Ænes et la copie avant de stocker cet espace dans un nouvel objet.
Il est √† noter que dans ces deux langages, le cas o√π plusieurs concat√©nations sont syntaxiquement effectu√©es
√† la suite est optimis√© et les concat√©nations individuelles sont remplac√©es par un \texttt{buffer}
et des ajouts mutables.

Ruby poss√®de plusieurs fa√ßons de concat√©ner des cha√Ænes, l'op√©rateur + ou l'op√©rateur \textless\textless.
La diff√©rence entre les deux est que \textless\textless est mutatif (et donc non-s√ªr
dans la mesure o√π un objet peut √™tre \texttt{frozen}\footnote{Rendu immutable par la fonction freeze du langage.})
l√† o√π + cr√©e une copie.
De par son caract√®re mutatif en revanche, \textless\textless  est plus efficace.

Des langages comme Python, ne poss√®dant pas de cha√Ænes mutables,
conseillent de passer par des tableaux de cha√Ænes dans le
cas de concat√©nations multiples, puis de joindre l'ensemble.
Il existe √©galement un op√©rateur + pour la concat√©nation simple.

\subsection{Acc√®s index√©}

Une autre op√©ration fr√©quente sur des cha√Ænes de caract√®res est l'acc√®s √† un caract√®re
de la cha√Æne.
D√©pendamment de la d√©finition de caract√®re, l'op√©ration change de sens.

La d√©finition de Java selon laquelle un caract√®re est un codet UTF-16 lui permet d'offrir
au programmeur une complexit√© temporelle en O(1) pour l'acc√®s √† un caract√®re, peu importe
sa position dans la cha√Æne.
Le probl√®me de cette approche est que selon Unicode, un point de code est potentiellement
cod√© sur 32 bits, laissant au programmeur le soin de g√©rer les paires compl√©mentaires.
Il s'agit d'un probl√®me r√©current dans les impl√©mentations des cha√Ænes utilisant UTF-16
(C\# et Python 2.x souffrent du probl√®me par exemple),
qui peut sembler fonctionnel tant que le texte contient uniquement des caract√®res du 
BMP\footnote{Basic Multilingual Plane, les 65535 premiers caract√®res de la norme Unicode,
repr√©sentant les langues vivantes actuelles.}; le cas le plus fr√©quent.
Cependant, lorsque le texte contient des caract√®res en dehors de ce plan, un acc√®s index√©
ne renverra qu'une partie de ce caract√®re, provoquant des comportements bogu√©s.

Des langages comme Go fournissent une interface de r√©cup√©ration de Runes respectant
le standard √©tabli par Unicode.
En UTF-8 ou UTF-16, les codages √©tant de longueur variable, l'acc√®s √† un caract√®re
est donc en complexit√© O(n).
UTF-32 √©tant √©galement support√© par le langage et de par son statut de codage √†
longueur fixe, il offre un acc√®s en temps constant.

Des langages comme Swift, traitant les caract√®res comme des graph√®mes, sont
oblig√©s de g√©rer les possibilit√©s de points de code combinants\footnote{Fa√ßon de g√©rer les caract√®res avec diacritiques par un syst√®me de combinaison.}
suivant un point de code quelconque.
Une premi√®re op√©ration de r√©cup√©ration d'un caract√®re est effectu√©e en un premier temps, de complexit√©
temporelle lin√©aire.
S'en suit une phase de lookahead pour d√©terminer la pr√©sence de caract√®res combinants.
Cette op√©ration est potentiellement d√©g√©n√©rative, Unicode ne limitant pas le nombre de
caract√®res combinants apr√®s un caract√®re de base.

\subsection{Sous-cha√Ænage}

La derni√®re op√©ration fondamentale des cha√Ænes de caract√®res est la production de
sous-cha√Ænes.
Lorsque l'on travaille avec des cha√Ænes de caract√®res, il est souvent n√©cessaire
de travailler sur des sous-parties d'une plus grande cha√Æne.
La fa√ßon simple de proc√©der est d'en extraire une sous-cha√Æne ind√©pendante sur
laquelle effectuer un traitement ult√©rieur.

Il existe deux fa√ßons principales de produire des sous-cha√Ænes: par copie ou par r√©f√©rence.
La copie est utilis√©e en C\# par exemple; √† chaque appel √† \texttt{substring}
un nouvel espace est allou√© et le contenu de la cha√Æne est copi√©, occasionnant une
complexit√© temporelle et spatiale de O(n).
L'avantage de la manoeuvre est que la cha√Æne de base n'est plus r√©f√©renc√©e et peut √™tre
d√©sallou√©e de fa√ßon s√ªre.
Le principal d√©savantage vient des manoeuvres de r√©allocation et copie qui d√©g√©n√®rent
sur de grandes cha√Ænes.

Java est √©galement de ces langages √† allouer de nouvelles cha√Ænes √† chaque appel √†
\texttt{substring}.
Cependant, ce n'est le comportement par d√©faut que depuis la version 7 update 6.
Avant cela, les donn√©es de la cha√Æne √©taient partag√©es entre plusieurs instances,
le d√©but de la cha√Æne √©tait stock√© dans la structure elle-m√™me sous la forme d'un
d√©calage et d'une longueur pr√©-d√©finie.
La raison de ce changement est au niveau de l'utilisation de la m√©moire, les sous-cha√Ænes
emp√™chant le ramassage de la cha√Æne parente, si cette derni√®re est large, elle peut
occasionner des probl√®mes de capacit√© m√©moire.
Un autre point invoqu√© est la non-applicabilit√© de la complexit√© O(1) sur une cha√Æne
de petite taille; essentiellement, une allocation et une copie pour un petit espace
de donn√©es est n√©gligeable par rapport au
maintien des indices et aux co√ªts additionnels des op√©rations
dans le cas d'une cha√Æne partag√©e.

\section{Conclusion}

Ce chapitre pr√©sente les diff√©rents points de variabilit√© des cha√Ænes de caract√®res dans les
langages de programmation.
Qu'il s'agisse de diff√©rences structurelles, de codage ou de mutabilit√©; chaque langage poss√®de
une id√©e qui lui est propre de la cha√Æne de caract√®res.
Ces choix poss√®dent tous des avantages et des inconv√©nients, et il n'existe pas, ni n'existera
un jour, de cha√Æne de caract√®res parfaite, d√©pourvue d'inconv√©nients.
En revanche, il est possible de limiter les inconv√©nients de chaque approche, tout en
gardant les avantages de chaque repr√©sentation.
Le prochain chapitre pr√©sente la solution que nous avons impl√©ment√©e en Nit, et qui repr√©sente
selon nous un bon compromis entre tous les points soulev√©s ici.
